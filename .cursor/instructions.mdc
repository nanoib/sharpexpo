---
description: 'Main Development Guidelines for the Project'
alwaysApply: true
---

## Project Overview

This project dedicates to copy UI of the real-existing sophisticated CAD software to improve it usability and user experience.

Follow these guidelines to generate clean, maintainable C# code for AI-first development.

## AI-First Development Principles

- **Linear, step-by-step code flows** - Avoid complex nested logic that's hard for AI to understand and modify
- **Comprehensive WHY documentation** - Every non-trivial decision should be explained in comments or XML docs
- **Explicit error conditions** - Handle and document all expected failure modes
- **Prefer immutable data structures** - Reduces state-related bugs and makes code more predictable
- **Single responsibility principle** - Each method and class should have one clear purpose

## Code Standards

### General Standards

- When building or testing some project, run full solution build. Per-project building or testing is not allowed
- Follow the project's [.editorconfig](../../.editorconfig) file for formatting, naming, and code style conventions
- Add XML doc comments (`///`) above every public class and method following [csharp-docs.prompt.mdc](./csharp-docs.prompt.mdc)
- Keep each method focused on a single responsibility and follow SOLID principles
- Name files to match the primary class they contain
- Organize code into folders by feature
- Use `using` directives only for namespaces you reference
- Avoid magic stringsâ€”define all literal strings as `const` or resource entries
- Encapsulate long event handlers by extracting helper methods
- Always check for `null` before accessing object members (or use nullable reference types appropriately)
- Group related properties in region blocks with clear names
- Prefer `ArgumentNullException.ThrowIfNull(param)` over manual `if (param == null) throw new ArgumentNullException(nameof(param));` patterns for parameter validation


## Project Configuration

### Framework Settings

- Enable nullable reference types across ALL projects: set `<Nullable>enable</Nullable>` in every `.csproj` and use correct annotations (`?`, `!`) to fix warnings gradually. Temporary suppressions are allowed only at narrow scope when interacting with external APIs
- Use C# 12+ features: primary constructors, collection expressions, and .NET 8 optimizations like `StringBuilder.AppendLine()` for string concatenation
- Build the project after every significant change using `dotnet build --no-incremental` to ensure a full rebuild

### Testing

- Write unit tests for all non-UI logic in separate test projects following [csharp-nunit.prompt.mdc](../../tests/.cursor/rules/csharp-nunit.prompt.mdc)
- Use dependency injection for services and providers to enable proper testing
- Follow [csharp-async.prompt.mdc](./csharp-async.prompt.mdc) for async code patterns

## Documentation

- Create comprehensive XML documentation comments for all public classes, interfaces, methods, and properties as described in [csharp-docs.prompt.mdc](./csharp-docs.prompt.mdc)
- When task is approved to be done, update documentation in the [docs](docs) folder. Do not create excessive documentation, but ensure all non-trivial logic is explained

## Architecture Patterns

### Dependency Injection

- Use constructor dependency injection with null checks via ArgumentNullException
- Register services with appropriate lifetimes (Singleton, Scoped, Transient)
- Use Microsoft.Extensions.DependencyInjection patterns
- Implement service interfaces for testability
- Use primary constructor syntax for dependency injection (e.g., `public class MyClass(IDependency dependency)`)

### Design Patterns

- Implement the Command Handler pattern with generic base classes (e.g., `CommandHandler<TOptions>`)
- Use interface segregation with clear naming conventions (prefix interfaces with 'I')
- Follow the Factory pattern for complex object creation

## Error Management

- Use structured logging with consistent message formats that is managed in [LoggingPipeServerService](./../../src/Rca.Loader/Logging/LoggingPipeServerService.cs)
- Provide meaningful error messages
- Log technical details for debugging purposes
- Use appropriate exception types for different error conditions

## Resource Management

### Localization

- Use ResourceManager for localized messages and error strings
- Separate LogMessages and ErrorMessages resource files
- Access resources via `_resourceManager.GetString("MessageKey")`

### Configuration

- Use strongly-typed configuration classes with data annotations
- Implement validation attributes (Required, NotEmptyOrWhitespace)
- Use IConfiguration binding for settings
- For user or developer debug settings, use [settings service](./../../src/Rca.Loader/Configuration/SettingsService.cs)

## Code Quality

- Follow SOLID principles: Single Responsibility (one reason to change), Open/Closed (open for extension, closed for modification), Liskov Substitution (subtypes must be substitutable), Interface Segregation (many specific interfaces), Dependency Inversion (depend on abstractions)
- Avoid code duplication through base classes and utilities
- Use descriptive names that clearly indicate purpose (e.g., `GetUserByIdAsync` not `GetData`)
- Keep methods under 50 lines and focused on single operation
- Implement `IDisposable` for classes managing unmanaged resources, use `using` statements for cleanup

## Conclusion

This project is designed to be maintained primarily by AI agents, so prioritize clarity, consistency, and comprehensive documentation over brevity.